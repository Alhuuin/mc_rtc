#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import git
import os
import re
import sys

def new_controller(project_dir, controller_class_name, controller_name, base_class = 'mc_control::MCController', base_use_conf = False, extra_includes = [], extra_libs = '', min_code = True):
    if not os.path.isabs(project_dir):
        return new_controller(os.path.abspath(project_dir), controller_class_name, controller_name, base_class, base_use_conf, extra_includes, extra_libs, min_code)
    extra_includes = '\n'.join(['#include <{}>'.format(i) for i in extra_includes])
    if len(extra_libs):
        extra_libs = 'target_link_libraries(${{PROJECT_NAME}} {})'.format(extra_libs)
    if controller_name is None:
        return new_controller(project_dir, controller_class_name, controller_class_name, base_class, base_use_conf, extra_includes, extra_libs, min_code)
    if os.path.exists(project_dir):
        print "{} already exists, aborting project creation".format(project_dir)
        sys.exit(1)
    if re.match('[A-Z][A-z0-9]*', controller_class_name) is None:
        print "Controller class name must start with a capital letter and be composed of letters and numbers only"
        sys.exit(1)
    os.makedirs(project_dir)
    repo = git.Repo.init(project_dir)
    repo.create_submodule('cmake', 'cmake', url = 'https://github.com/jrl-umi3218/jrl-cmakemodules')
    os.makedirs(project_dir + '/src')
    os.makedirs(project_dir + '/etc')
    with open(project_dir + '/CMakeLists.txt', 'w') as fd:
        fd.write("""cmake_minimum_required(VERSION 2.8)

set(CXX_DISABLE_WERROR 1)
include(cmake/base.cmake)
include(cmake/boost.cmake)

set(PROJECT_NAME {controller_class_name})
set(PROJECT_DESCRIPTION "{controller_name}")
set(PROJECT_URL "")

setup_project()

# Enable C++11
if(NOT WIN32)
  add_definitions(-std=c++0x)
endif()

# Use jrl-cmakemoduels to get mc_rtc depency
set(PKG_CONFIG_ADDITIONAL_VARIABLES "${{PKG_CONFIG_ADDITIONAL_VARIABLES}} libdir prefix")
add_required_dependency(mc_rtc)

add_subdirectory(src)

install(FILES etc/{controller_name}.conf DESTINATION "${{MC_RTC_LIBDIR}}/mc_controller/etc")

setup_project_finalize()""".format(controller_name = controller_name, controller_class_name = controller_class_name))
    with open(project_dir + '/src/CMakeLists.txt', 'w') as fd:
        fd.write("""set(controller_SRC
  {controller_class_name}.cpp
)

set(controller_HDR
  {controller_class_name}.h
)

add_library(${{PROJECT_NAME}} SHARED ${{controller_SRC}} ${{controller_HDR}})
set_target_properties(${{PROJECT_NAME}} PROPERTIES COMPILE_FLAGS "-DMC_CONTROL_EXPORTS" PREFIX "")
pkg_config_use_dependency(${{PROJECT_NAME}} mc_rtc)
{extra_libs}
install(TARGETS ${{PROJECT_NAME}} DESTINATION ${{MC_RTC_LIBDIR}}/mc_controller)""".format(controller_class_name = controller_class_name, extra_libs = extra_libs))
    with open(project_dir + '/src/' + controller_class_name + '.h', 'w') as fd:
        fd.write("""#pragma once

#include <mc_control/mc_controller.h>
{extra_includes}

struct MC_CONTROL_DLLAPI {controller_class_name} : public {base_class}
{{
    {controller_class_name}(mc_rbdyn::RobotModulePtr rm, double dt, const mc_rtc::Configuration & config);

    bool run() override;

    void reset(const mc_control::ControllerResetData & reset_data) override;
private:
    mc_rtc::Configuration config_;
}};""".format(controller_class_name = controller_class_name, base_class = base_class, extra_includes = extra_includes))

    with open(project_dir + '/src/' + controller_class_name + '.cpp', 'w') as fd:
        base_init = "{}(rm, dt".format(base_class)
        if base_use_conf:
            base_init += ", config"
        base_init += ')'
        if min_code:
            min_code = """  config_.load(config);
  solver().addConstraintSet(contactConstraint);
  solver().addConstraintSet(kinematicsConstraint);
  solver().addTask(postureTask);
  solver().setContacts({{}});
"""
        else:
            min_code = ""
        fd.write("""#include "{controller_class_name}.h"

{controller_class_name}::{controller_class_name}(mc_rbdyn::RobotModulePtr rm, double dt, const mc_rtc::Configuration & config)
: {base_init}
{{
{min_code}
  LOG_SUCCESS("{controller_name} init done " << this)
}}

bool {controller_class_name}::run()
{{
  return {base_class}::run();
}}

void {controller_class_name}::reset(const mc_control::ControllerResetData & reset_data)
{{
  {base_class}::reset(reset_data);
}}

CONTROLLER_CONSTRUCTOR("{controller_name}", {controller_class_name})
""".format(controller_class_name = controller_class_name, controller_name = controller_name, base_class = base_class, base_init = base_init, min_code = min_code))
    with open(project_dir + '/etc/' + controller_name + '.conf', 'w') as fd:
        fd.write("{\n}")
    repo.index.add([s.format(controller_class_name) for s in ['CMakeLists.txt', 'src/CMakeLists.txt', 'etc/' + controller_name + '.conf', 'src/{}.h', 'src/{}.cpp']])
    return repo

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Create a new mc_rtc Controller project')
    parser.add_argument('project_dir', metavar='[project directory]', type=str, help='Path of the project')
    parser.add_argument('controller_class_name', metavar='[controller class name]', type=str, help='Name of the controller class')
    parser.add_argument('controller_name', metavar='[controller name]', nargs='?', type=str, help='Name of the controller, defaults to controller class name', default=None)
    args = parser.parse_args()
    repo = new_controller(args.project_dir, args.controller_class_name, args.controller_name)
    repo.index.commit("Initial commit")
