#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import imp
import os

mod = imp.load_source('mc_rtc_new_controller', os.path.dirname(__file__) + '/mc_rtc_new_controller')
new_controller = mod.new_controller

def new_fsm_controller(project_dir, controller_class_name, controller_name):
    if not os.path.isabs(project_dir):
        return new_fsm_controller(os.path.abspath(project_dir), controller_class_name, controller_name)
    if controller_name is None:
        return new_fsm_controller(project_dir, controller_class_name, controller_class_name)
    repo = new_controller(project_dir, controller_class_name, controller_name, base_class = 'mc_control::fsm::Controller', base_use_conf = True, extra_includes = ['mc_control/fsm/Controller.h'], extra_libs = 'mc_control_fsm', min_code = False)
    with open(project_dir + '/etc/{}.conf'.format(controller_name), 'w') as fd:
        fd.write("""{{
  // If true, the FSM transitions are managed by an external tool
  "Managed": false,
  // If true and the FSM is self-managed, transitions should be triggered
  "StepByStep": true,
  // Change idle behaviour, if true the state is kept until transition,
  // otherwise the FSM holds the last state until transition
  "IdleKeepState": false,
  // Where to look for state libraries
  "StatesLibraries": ["/usr/local/lib/mc_controller/{controller_name}/states"],
  // Where to look for state files
  "StatesFiles": ["/usr/local/lib/mc_controller/{controller_name}/states/data"],
  // If true, state factory will be more verbose
  "VerboseStateFactory": false,
  // Additional robots to load
  "robots":
  {{
    "ground":
    {{
      "module": "env",
      "params": ["@MC_ENV_DESCRIPTION@", "ground"]
    }}
  }},
  // General constraints, always on
  "constraints":
  [
    {{
      "type": "contact"
    }},
    {{
      "type": "dynamics",
      "robotIndex": 0,
      "damper": [0.1, 0.01, 0.5]
    }}
  ],
  // Collision constraint
  "collisions":
  [
    {{
      "type": "collision",
      "r1Index": 0,
      "r2Index": 0,
      "useMinimal": true
    }}
  ],
  // Initial set of contacts
  "contacts":
  [
    {{
      "r1": "hrp2_drc",
      "r2": "ground",
      "r1Surface": "LFullSole",
      "r2Surface": "AllGround"
    }},
    {{
      "r1": "hrp2_drc",
      "r2": "ground",
      "r1Surface": "RFullSole",
      "r2Surface": "AllGround"
    }}
  ],
  // Some options for a specific robot
  "hrp2_drc":
  {{
    "posture":
    {{
      "stiffness": 1.0,
      "weight": 10.0
    }},
    "ff":
    {{
      "stiffness": 2.0,
      "weight": 100.0
    }}
  }},
  // Implement some additional text states
  "states":
  {{
  }},
  // Transitions map
  "transitions":
  [
    ["{controller_name}_Initial", "OK", "{controller_name}_Initial", "Strict" ]
  ],
  // Initial state
  "init": "{controller_name}_Initial"
}}""".format(controller_name = controller_name, controller_class_name = controller_class_name))

    os.makedirs(project_dir + '/src/states/data')
    with open(project_dir + '/src/CMakeLists.txt', 'a') as fd:
        fd.write('\nadd_subdirectory(states)')
    with open(project_dir + '/src/states/data/states.json', 'w') as fd:
        fd.write('{\n}')
    with open(project_dir + '/src/states/CMakeLists.txt', 'w') as fd:
        fd.write("""set(FSM_STATES_INSTALL_PREFIX "${{MC_RTC_LIBDIR}}/mc_controller/{controller_name}/states")

install(DIRECTORY data DESTINATION ${{FSM_STATES_INSTALL_PREFIX}} FILES_MATCHING PATTERN "*.json")

macro(add_fsm_state state_name state_SRC state_HDR)
  add_library(${{state_name}} SHARED  ${{state_SRC}} ${{state_HDR}})
  set_target_properties(${{state_name}} PROPERTIES PREFIX "")
  target_link_libraries(${{state_name}} ${{PROJECT_NAME}})
  install(TARGETS ${{state_name}} DESTINATION ${{FSM_STATES_INSTALL_PREFIX}})
endmacro()

macro(add_fsm_state_simple state_name)
  add_fsm_state(${{state_name}} ${{state_name}}.cpp ${{state_name}}.h)
endmacro()

add_fsm_state_simple({controller_name}_Initial)
""".format(controller_name = controller_name))
    with open(project_dir + '/src/states/{}_Initial.h'.format(controller_name), 'w') as fd:
        fd.write("""#pragma once

#include <mc_control/fsm/State.h>

struct {controller_name}_Initial : mc_control::fsm::State
{{

    void configure(const mc_rtc::Configuration & config) override;

    void start(mc_control::fsm::Controller & ctl) override;

    bool run(mc_control::fsm::Controller & ctl) override;

    void teardown(mc_control::fsm::Controller & ctl) override;
private:
}};
""".format(controller_name = controller_name))
    with open(project_dir + '/src/states/{}_Initial.cpp'.format(controller_name), 'w') as fd:
        fd.write("""#include "{controller_name}_Initial.h"

#include "../{controller_class_name}.h"

void {controller_name}_Initial::configure(const mc_rtc::Configuration & config)
{{
}}

void {controller_name}_Initial::start(mc_control::fsm::Controller & ctl_)
{{
  auto & ctl = static_cast<{controller_class_name} &>(ctl_);
}}

bool {controller_name}_Initial::run(mc_control::fsm::Controller & ctl_)
{{
  auto & ctl = static_cast<{controller_class_name} &>(ctl_);
  return true;
}}

void {controller_name}_Initial::teardown(mc_control::fsm::Controller & ctl_)
{{
  auto & ctl = static_cast<{controller_class_name} &>(ctl_);
}}

EXPORT_SINGLE_STATE("{controller_name}_Initial", {controller_name}_Initial)
""".format(controller_name = controller_name, controller_class_name = controller_class_name))
    repo.index.add([(project_dir + f).format(controller_name) for f in ['/etc/{}.conf', '/src/CMakeLists.txt', '/src/states/data/states.json', '/src/states/CMakeLists.txt', '/src/states/{}_Initial.h', '/src/states/{}_Initial.cpp']])
    return repo

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Create a new mc_rtc FSM project')
    parser.add_argument('project_dir', metavar='[project directory]', type=str, help='Path of the project')
    parser.add_argument('controller_class_name', metavar='[controller class name]', type=str, help='Name of the controller class')
    parser.add_argument('controller_name', metavar='[controller name]', nargs='?', type=str, help='Name of the controller, defaults to controller class name', default=None)
    args = parser.parse_args()
    repo = new_fsm_controller(args.project_dir, args.controller_class_name, args.controller_name)
    repo.index.commit("Initial commit")
